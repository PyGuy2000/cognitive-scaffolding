enhanced_manim_components:

  # Domain-Specific Character Templates
  characters:
    service_coordination:
      coordinator:
        class: "VGroup"
        components:
          base: "Circle(radius=0.6, color=BLUE, fill_opacity=0.8)"
          label: "Text('Coordinator', font_size=20)"
          badge: "Star(color=GOLD).scale(0.3)"
        positioning: "LEFT*3"
        animations: ["FadeIn", "Indicate", "Transform", "Flash"]
        
      service_worker:
        class: "VGroup" 
        components:
          base: "Rectangle(width=1.2, height=0.8, color=GREEN, fill_opacity=0.6)"
          label: "Text('Service', font_size=16)"
        positioning: "RIGHT*2"
        animations: ["Create", "FadeIn", "Pulse"]
        
      user:
        class: "VGroup"
        components:
          base: "Circle(radius=0.4, color=YELLOW, fill_opacity=0.9)"
          label: "Text('User', font_size=18)"
        positioning: "LEFT*4"
        animations: ["FadeIn", "Indicate"]

    navigation_movement:
      explorer:
        class: "VGroup"
        components:
          base: "Triangle(color=RED, fill_opacity=0.8)"
          trail: "TracedPath(stroke_color=RED, stroke_width=2)"
        positioning: "LEFT*3 + DOWN*2"
        animations: ["FadeIn", "MoveAlongPath", "Rotate"]
        
      landmark:
        class: "VGroup"
        components:
          base: "Star(color=YELLOW, fill_opacity=0.8)"
          label: "Text('Goal', font_size=16, color=YELLOW)"
        positioning: "RIGHT*2 + UP*1"
        animations: ["FadeIn", "Flash", "Pulse"]
        
      terrain:
        class: "Surface"
        components:
          base: "NumberPlane(x_range=[-4, 4], y_range=[-3, 3])"
          obstacles: "VGroup(*[Circle(radius=0.3, color=GRAY) for _ in range(3)])"
        animations: ["Create", "FadeIn"]

    social_interaction:
      person:
        class: "VGroup"
        components:
          base: "Circle(radius=0.4, color=BLUE, fill_opacity=0.7)"
          expression: "Arc(radius=0.2, start_angle=PI, angle=PI)"
          label: "Text('Person', font_size=14)"
        animations: ["FadeIn", "Indicate", "Transform"]
        
      conversation_bubble:
        class: "VGroup"
        components:
          bubble: "RoundedRectangle(width=2, height=1, corner_radius=0.2)"
          text: "Text('Message', font_size=14)"
          pointer: "Triangle().scale(0.2)"
        animations: ["Write", "FadeIn", "FadeOut"]
        
      attention_center:
        class: "VGroup"
        components:
          core: "Dot(radius=0.2, color=RED)"
          field: "Circle(radius=2, color=RED, fill_opacity=0.1)"
        animations: ["Create", "Pulse", "Expand"]

  # Environment Templates
  environments:
    office_setup:
      components:
        room: "Rectangle(width=12, height=8, color=BLUE, fill_opacity=0.1)"
        desk: "Rectangle(width=6, height=2, color=BROWN, fill_opacity=0.3)"
        computers: "VGroup(*[Rectangle(width=1, height=0.7, color=GRAY) for _ in range(4)])"
      layout: "grid"
      
    landscape:
      components:
        terrain: "NumberPlane(background_line_style={'stroke_opacity': 0.3})"
        hills: "VGroup(*[Arc(radius=2, angle=PI) for _ in range(3)])"
        paths: "VGroup(*[CubicBezier() for _ in range(2)])"
      layout: "natural"
      
    network_diagram:
      components:
        nodes: "VGroup(*[Circle(radius=0.3) for _ in range(6)])"
        connections: "VGroup(*[Line() for _ in range(8)])"
        data_flow: "VGroup(*[Arrow() for _ in range(5)])"
      layout: "force_directed"

  # Animation Patterns by Domain
  animation_patterns:
    service_coordination:
      parallel_processing:
        description: "Show multiple services working simultaneously"
        implementation: |
          # Create multiple arrows from coordinator to services
          arrows = VGroup(*[Arrow(coordinator.get_center(), service.get_center()) 
                           for service in services])
          self.play(AnimationGroup(*[Create(arrow) for arrow in arrows], lag_ratio=0.1))
          
          # Show simultaneous processing
          for arrow in arrows:
              self.play(Flash(arrow), run_time=0.5)
              
      coordination_workflow:
        description: "Demonstrate request routing and response gathering"
        implementation: |
          # Show request flow
          request = Dot(color=YELLOW).move_to(user.get_center())
          self.play(request.animate.move_to(coordinator.get_center()))
          
          # Distribute to services
          sub_requests = VGroup(*[request.copy() for _ in services])
          self.play(AnimationGroup(*[req.animate.move_to(service.get_center()) 
                                   for req, service in zip(sub_requests, services)]))

    navigation_movement:
      pathfinding:
        description: "Show exploration and path optimization"
        implementation: |
          # Create exploration trail
          path_points = [explorer.get_center()]
          for _ in range(5):
              new_point = path_points[-1] + np.random.uniform(-1, 1, 3)
              path_points.append(new_point)
              
          # Animate movement
          for point in path_points[1:]:
              self.play(explorer.animate.move_to(point), run_time=0.8)
              
      gradient_descent:
        description: "Show optimization process with elevation visualization"
        implementation: |
          # Create elevation surface
          surface = Surface(
              lambda u, v: [u, v, np.sin(u) * np.cos(v)],
              u_range=[-3, 3], v_range=[-3, 3]
          )
          
          # Show descent path
          descent_path = ParametricFunction(
              lambda t: [t, 0.5*t, np.sin(t)*np.cos(0.5*t)],
              t_range=[-2, 2]
          )

    social_interaction:
      attention_mechanism:
        description: "Show selective attention in conversations"
        implementation: |
          # Create attention lines
          attention_lines = VGroup(*[DashedLine(
              attention_center.get_center(), 
              person.get_center(),
              color=RED
          ) for person in people])
          
          # Animate attention shifting
          for i, line in enumerate(attention_lines):
              self.play(Create(line))
              self.play(Flash(people[i]))
              if i < len(attention_lines) - 1:
                  self.play(FadeOut(line))
                  
      conversation_flow:
        description: "Show multi-party conversation dynamics"
        implementation: |
          # Create conversation arcs
          conversations = [
              Arc(start_angle=0, angle=PI/2).move_to(
                  Line(person1.get_center(), person2.get_center()).get_center()
              ) for person1, person2 in conversation_pairs
          ]
          
          # Animate conversation waves
          self.play(AnimationGroup(*[Create(conv) for conv in conversations]))

  # Visual Effects Library
  effects:
    data_flow:
      particles:
        class: "VGroup"
        generator: |
          particles = VGroup(*[
              Dot(radius=0.05, color=BLUE).move_to(
                  start_point + np.random.uniform(-0.2, 0.2, 3)
              ) for _ in range(10)
          ])
        animation: "particles.animate.move_to(end_point)"
        
    processing_indicator:
      spinner:
        class: "Arc"
        properties: "radius=0.5, start_angle=0, angle=PI/2, color=GREEN"
        animation: "Rotate(about_point=ORIGIN, angle=2*PI)"
        
    transformation:
      morph:
        description: "Transform one shape into another"
        implementation: "Transform(source_shape, target_shape)"
        
      fade_transition:
        description: "Fade out old, fade in new"
        implementation: "AnimationGroup(FadeOut(old), FadeIn(new))"

  # Scene Templates
  scene_templates:
    introduction:
      structure:
        - element: "title"
          duration: 2
          animation: "Write"
        - element: "subtitle" 
          duration: 1.5
          animation: "Write"
        - element: "logo_or_visual"
          duration: 1
          animation: "FadeIn"
        - element: "transition_out"
          duration: 1
          animation: "FadeOut"

    problem_setup:
      structure:
        - element: "problem_statement"
          duration: 3
          animation: "Write"
        - element: "current_limitations"
          duration: 2
          animation: "FadeIn"
        - element: "pain_points"
          duration: 2
          animation: "Indicate"

    solution_demonstration:
      structure:
        - element: "solution_introduction"
          duration: 2
          animation: "FadeIn"
        - element: "key_mechanism"
          duration: 4
          animation: "Transform"
        - element: "benefits_highlight"
          duration: 3
          animation: "Flash"

    comparison:
      layout: "split_screen"
      structure:
        - element: "divider_line"
          animation: "Create"
        - element: "before_after_labels"
          animation: "Write"
        - element: "side_by_side_demo"
          animation: "AnimationGroup"

    conclusion:
      structure:
        - element: "key_takeaway"
          duration: 3
          animation: "Write"
        - element: "call_to_action"
          duration: 2
          animation: "FadeIn"
        - element: "final_visual"
          duration: 2
          animation: "Flash"

  # Advanced Scene Generators
  scene_generators:
    orchestration_demo:
      concept_types: ["service_coordination", "system_architecture"]
      template: |
        def orchestration_scene(self):
            # Setup coordinator and services
            coordinator = self.create_coordinator()
            services = self.create_services(count=4)
            
            # Show initial setup
            self.play(FadeIn(coordinator))
            self.play(AnimationGroup(*[FadeIn(service) for service in services]))
            
            # Demonstrate coordination
            request = self.create_request()
            self.show_request_distribution(request, coordinator, services)
            self.show_parallel_processing(services)
            self.show_response_aggregation(services, coordinator)
            
            return coordinator, services

    learning_journey:
      concept_types: ["navigation_movement", "educational_progression"]
      template: |
        def learning_journey_scene(self):
            # Create learning landscape
            landscape = self.create_learning_landscape()
            learner = self.create_learner()
            milestones = self.create_milestones()
            
            # Show progression
            self.play(Create(landscape))
            self.play(FadeIn(learner))
            
            for milestone in milestones:
                self.show_learning_step(learner, milestone)
                self.show_knowledge_gained()
            
            return learner, milestones

    social_network_demo:
      concept_types: ["social_interaction", "attention_mechanism"]
      template: |
        def social_network_scene(self):
            # Create participants
            people = self.create_people(count=5)
            attention_mechanism = self.create_attention_center()
            
            # Show conversations
            self.play(AnimationGroup(*[FadeIn(person) for person in people]))
            self.play(FadeIn(attention_mechanism))
            
            # Demonstrate attention flow
            self.show_attention_distribution(attention_mechanism, people)
            self.show_context_understanding()
            
            return people, attention_mechanism

  # Utility Functions for Scene Generation
  utility_functions:
    coordinate_helpers:
      circular_arrangement: |
        def arrange_in_circle(objects, radius=3, center=ORIGIN):
            n = len(objects)
            for i, obj in enumerate(objects):
                angle = i * 2 * PI / n
                position = center + radius * np.array([np.cos(angle), np.sin(angle), 0])
                obj.move_to(position)
            return objects

      grid_arrangement: |
        def arrange_in_grid(objects, cols=3, spacing=2):
            for i, obj in enumerate(objects):
                row = i // cols
                col = i % cols
                position = np.array([col * spacing, -row * spacing, 0])
                obj.move_to(position)
            return objects

    animation_helpers:
      staggered_animation: |
        def staggered_fade_in(objects, lag_ratio=0.2):
            return AnimationGroup(
                *[FadeIn(obj) for obj in objects],
                lag_ratio=lag_ratio
            )

      wave_effect: |
        def create_wave_effect(objects, amplitude=0.5, frequency=2):
            animations = []
            for i, obj in enumerate(objects):
                wave = obj.animate.shift(UP * amplitude * np.sin(frequency * i))
                animations.append(wave)
            return AnimationGroup(*animations)

    text_helpers:
      typewriter_effect: |
        def typewriter_text(text, font_size=24, color=WHITE):
            text_obj = Text(text, font_size=font_size, color=color)
            return Write(text_obj, run_time=len(text) * 0.1)

      highlight_effect: |
        def highlight_text(text_obj, color=YELLOW):
            highlight = Rectangle(
                width=text_obj.width + 0.2,
                height=text_obj.height + 0.1,
                color=color,
                fill_opacity=0.3
            ).move_to(text_obj)
            return highlight

  # Domain-Specific Configurations
  domain_configs:
    service_coordination:
      color_scheme:
        coordinator: "#FF6B6B"
        services: "#4ECDC4" 
        connections: "#45B7D1"
        data_flow: "#96CEB4"
      
      timing:
        setup_duration: 2
        coordination_duration: 4
        processing_duration: 3
        completion_duration: 2
      
      sound_cues:
        coordination_start: "orchestral_chord.wav"
        processing: "mechanical_hum.wav"
        completion: "success_chime.wav"

    navigation_movement:
      color_scheme:
        explorer: "#E74C3C"
        terrain: "#8E44AD"
        goal: "#F39C12"
        path: "#27AE60"
      
      movement_style:
        speed: "moderate"
        trail_fade: 0.8
        bounce_factor: 0.1
      
      terrain_complexity:
        simple: "flat_plane"
        moderate: "rolling_hills"
        complex: "mountain_range"

    social_interaction:
      color_scheme:
        people: "#3498DB"
        attention: "#E74C3C"
        conversations: "#2ECC71"
        understanding: "#F1C40F"
      
      interaction_patterns:
        attention_shift_speed: 1.5
        conversation_overlap: 0.3
        understanding_buildup: 2.0

  # Export and Rendering Configurations
  rendering_configs:
    quality_presets:
      draft:
        resolution: "480p"
        frame_rate: 15
        quality_flag: "-ql"
        render_time_estimate: "30 seconds"
      
      standard:
        resolution: "720p"
        frame_rate: 30
        quality_flag: "-qm"
        render_time_estimate: "2-3 minutes"
      
      high:
        resolution: "1080p"
        frame_rate: 60
        quality_flag: "-qh"
        render_time_estimate: "5-8 minutes"
      
      presentation:
        resolution: "4k"
        frame_rate: 60
        quality_flag: "-qk"
        render_time_estimate: "15-25 minutes"

    export_formats:
      video:
        mp4: "Standard video format for presentations"
        mov: "High quality for professional editing"
        avi: "Compatibility format"
      
      image_sequence:
        png: "High quality stills"
        jpg: "Compressed stills"
        svg: "Vector graphics (limited support)"
      
      gif:
        standard: "Web-friendly animations"
        high_quality: "Larger file size, better quality"

    optimization_tips:
      performance:
        - "Use VGroup for complex objects"
        - "Minimize Transform() operations"
        - "Pre-calculate positions when possible"
        - "Use AnimationGroup with lag_ratio for staggered effects"
      
      memory:
        - "Clear unused objects with remove()"
        - "Use object pooling for repeated elements"
        - "Avoid creating too many simultaneous objects"
      
      render_speed:
        - "Use lower quality for iteration"
        - "Preview specific scenes with -s flag"
        - "Use --dry_run to check for errors"

# Integration Instructions
integration_notes: |
  To use these enhanced Manim components:
  
  1. Import the component library in your Manim script:
     ```python
     from enhanced_manim_components import *
     ```
  
  2. Use scene templates as base classes:
     ```python
     class MyScene(orchestration_demo):
         def construct(self):
             super().orchestration_scene()
             # Add custom elements
     ```
  
  3. Apply domain configurations:
     ```python
     config = domain_configs["service_coordination"]
     self.camera.background_color = config["color_scheme"]["background"]
     ```
  
  4. Use utility functions for positioning:
     ```python
     objects = [Circle() for _ in range(5)]
     arrange_in_circle(objects, radius=2)
     ```

# Extensibility Framework
extensibility:
  custom_domains:
    template: |
      my_custom_domain:
        characters:
          custom_character:
            class: "VGroup"
            components:
              base: "Shape_definition"
              label: "Text_definition"
        
        animation_patterns:
          custom_pattern:
            description: "What this pattern demonstrates"
            implementation: |
              # Manim code for the pattern
  
  plugin_system:
    interface: |
      class ManimDomainPlugin:
          def get_characters(self):
              return self.characters
          
          def get_animations(self):
              return self.animation_patterns
          
          def get_scenes(self):
              return self.scene_templates
    
    registration: |
      # Register custom domains
      register_domain_plugin("my_domain", MyDomainPlugin())

# Validation and Testing
validation_rules:
  scene_structure:
    - "Each scene must have a construct() method"
    - "All animations must specify run_time"
    - "Objects must be properly positioned before animation"
  
  performance:
    - "Scene duration should not exceed 180 seconds"
    - "Animation groups should use appropriate lag_ratio"
    - "Complex objects should be created once and reused"
  
  accessibility:
    - "Color contrast must meet WCAG guidelines"
    - "Text must be readable at minimum font size"
    - "Animation speed should be adjustable"